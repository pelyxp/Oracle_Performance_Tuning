[toc]

![img](13_Index_01.assets/ef75ba49-d200-386e-bfb6-2cf2644ef2e2.jpg)

Leaf之间双向



## Index Unique Scan

只返回一条索引的时候，最快。

一般是主键。rowid

## Index Range Scan

返回值超过1条的时候，会采用Index Range Scan(不采用FTS的时候)

索引需要排序

排序才能进行Range Scan

### 范围索引扫描，会扫描几个分支块

索引高度=1

索引高度=2，扫描0个分支块

索引高度=3，扫描1个分支块

减掉1个root，1个leaf

分支与分支之间不可能有交集



#### FTS是多块读，索引是单块读

为什么索引扫描是单块读。物理上不连续。

#### 行迁移为什么是单块读

数据不相连

#### 为什么从Undo里面构建CR块是单块读

原始数据已经被覆盖，只能构造出来才能进行下一步的操作。Undo不连续。

### Index Range Scan IO的多少

Index Range Scan返回数据少，数据少，扫描块少，速度快

返回数据多了，扫描的快就多了，速度慢。

Index Range Scan不坑爹，坑爹的是回表。

`select * from test where id <=10000;`

返回1w条数据，回表10000次。

回表需要多少物理IO（集群因子）

假设一个叶子块存100条，要扫描100个叶子块，回表最坏情况要扫描10000个数据块，最理想是扫描几百个数据块。

回表比索引消耗的IO更多。

读到内存之后，

作业，写一个脚本，全自动的，把错误的Index Range Scan抓出来。表与表之间设计有问题的，都抓出来。





